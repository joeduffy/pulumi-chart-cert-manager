// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetescertmanager.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.kubernetes.apps.v1.inputs.DeploymentStrategyArgs;
import com.pulumi.kubernetes.core.v1.inputs.AffinityArgs;
import com.pulumi.kubernetes.core.v1.inputs.PodSecurityContextArgs;
import com.pulumi.kubernetes.core.v1.inputs.ProbeArgs;
import com.pulumi.kubernetes.core.v1.inputs.ResourceRequirementsArgs;
import com.pulumi.kubernetes.core.v1.inputs.SecurityContextArgs;
import com.pulumi.kubernetes.core.v1.inputs.TolerationArgs;
import com.pulumi.kubernetescertmanager.inputs.CertManagerImageArgs;
import com.pulumi.kubernetescertmanager.inputs.CertManagerServiceAccountArgs;
import com.pulumi.kubernetescertmanager.inputs.CertManagerWebhookURLArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class CertManagerWebhookArgs extends com.pulumi.resources.ResourceArgs {

    public static final CertManagerWebhookArgs Empty = new CertManagerWebhookArgs();

    @Import(name="affinity")
    private @Nullable Output<AffinityArgs> affinity;

    public Optional<Output<AffinityArgs>> affinity() {
        return Optional.ofNullable(this.affinity);
    }

    /**
     * Container Security Context to be set on the webhook component container. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * 
     */
    @Import(name="containerSecurityContext")
    private @Nullable Output<SecurityContextArgs> containerSecurityContext;

    /**
     * @return Container Security Context to be set on the webhook component container. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * 
     */
    public Optional<Output<SecurityContextArgs>> containerSecurityContext() {
        return Optional.ofNullable(this.containerSecurityContext);
    }

    /**
     * Optional additional annotations to add to the webhook Deployment
     * 
     */
    @Import(name="deploymentAnnotations")
    private @Nullable Output<Map<String,String>> deploymentAnnotations;

    /**
     * @return Optional additional annotations to add to the webhook Deployment
     * 
     */
    public Optional<Output<Map<String,String>>> deploymentAnnotations() {
        return Optional.ofNullable(this.deploymentAnnotations);
    }

    /**
     * Optional additional arguments for webhook
     * 
     */
    @Import(name="extraArgs")
    private @Nullable Output<List<String>> extraArgs;

    /**
     * @return Optional additional arguments for webhook
     * 
     */
    public Optional<Output<List<String>>> extraArgs() {
        return Optional.ofNullable(this.extraArgs);
    }

    /**
     * Specifies if the webhook should be started in hostNetwork mode. Required for use in some managed kubernetes clusters (such as AWS EKS) with custom CNI (such as calico), because control-plane managed by AWS cannot communicate with pods&#39; IP CIDR and admission webhooks are not working Since the default port for the webhook conflicts with kubelet on the host network, `webhook.securePort` should be changed to an available port if running in hostNetwork mode.
     * 
     */
    @Import(name="hostNetwork")
    private @Nullable Output<Boolean> hostNetwork;

    /**
     * @return Specifies if the webhook should be started in hostNetwork mode. Required for use in some managed kubernetes clusters (such as AWS EKS) with custom CNI (such as calico), because control-plane managed by AWS cannot communicate with pods&#39; IP CIDR and admission webhooks are not working Since the default port for the webhook conflicts with kubelet on the host network, `webhook.securePort` should be changed to an available port if running in hostNetwork mode.
     * 
     */
    public Optional<Output<Boolean>> hostNetwork() {
        return Optional.ofNullable(this.hostNetwork);
    }

    @Import(name="image")
    private @Nullable Output<CertManagerImageArgs> image;

    public Optional<Output<CertManagerImageArgs>> image() {
        return Optional.ofNullable(this.image);
    }

    /**
     * Liveness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
     * 
     */
    @Import(name="livenessProbe")
    private @Nullable Output<ProbeArgs> livenessProbe;

    /**
     * @return Liveness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
     * 
     */
    public Optional<Output<ProbeArgs>> livenessProbe() {
        return Optional.ofNullable(this.livenessProbe);
    }

    @Import(name="loadBalancerIP")
    private @Nullable Output<String> loadBalancerIP;

    public Optional<Output<String>> loadBalancerIP() {
        return Optional.ofNullable(this.loadBalancerIP);
    }

    /**
     * Optional additional annotations to add to the webhook MutatingWebhookConfiguration
     * 
     */
    @Import(name="mutatingWebhookConfigurationAnnotations")
    private @Nullable Output<Map<String,String>> mutatingWebhookConfigurationAnnotations;

    /**
     * @return Optional additional annotations to add to the webhook MutatingWebhookConfiguration
     * 
     */
    public Optional<Output<Map<String,String>>> mutatingWebhookConfigurationAnnotations() {
        return Optional.ofNullable(this.mutatingWebhookConfigurationAnnotations);
    }

    @Import(name="nodeSelector")
    private @Nullable Output<Map<String,String>> nodeSelector;

    public Optional<Output<Map<String,String>>> nodeSelector() {
        return Optional.ofNullable(this.nodeSelector);
    }

    /**
     * Optional additional annotations to add to the webhook Pods
     * 
     */
    @Import(name="podAnnotations")
    private @Nullable Output<Map<String,String>> podAnnotations;

    /**
     * @return Optional additional annotations to add to the webhook Pods
     * 
     */
    public Optional<Output<Map<String,String>>> podAnnotations() {
        return Optional.ofNullable(this.podAnnotations);
    }

    /**
     * Optional additional labels to add to the Webhook Pods
     * 
     */
    @Import(name="podLabels")
    private @Nullable Output<Map<String,String>> podLabels;

    /**
     * @return Optional additional labels to add to the Webhook Pods
     * 
     */
    public Optional<Output<Map<String,String>>> podLabels() {
        return Optional.ofNullable(this.podLabels);
    }

    /**
     * Readiness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
     * 
     */
    @Import(name="readinessProbe")
    private @Nullable Output<ProbeArgs> readinessProbe;

    /**
     * @return Readiness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
     * 
     */
    public Optional<Output<ProbeArgs>> readinessProbe() {
        return Optional.ofNullable(this.readinessProbe);
    }

    @Import(name="replicaCount")
    private @Nullable Output<Integer> replicaCount;

    public Optional<Output<Integer>> replicaCount() {
        return Optional.ofNullable(this.replicaCount);
    }

    @Import(name="resources")
    private @Nullable Output<ResourceRequirementsArgs> resources;

    public Optional<Output<ResourceRequirementsArgs>> resources() {
        return Optional.ofNullable(this.resources);
    }

    /**
     * The port that the webhook should listen on for requests. In GKE private clusters, by default kubernetes apiservers are allowed to talk to the cluster nodes only on 443 and 10250. so configuring securePort: 10250, will work out of the box without needing to add firewall rules or requiring NET_BIND_SERVICE capabilities to bind port numbers &lt;1000
     * 
     */
    @Import(name="securePort")
    private @Nullable Output<Integer> securePort;

    /**
     * @return The port that the webhook should listen on for requests. In GKE private clusters, by default kubernetes apiservers are allowed to talk to the cluster nodes only on 443 and 10250. so configuring securePort: 10250, will work out of the box without needing to add firewall rules or requiring NET_BIND_SERVICE capabilities to bind port numbers &lt;1000
     * 
     */
    public Optional<Output<Integer>> securePort() {
        return Optional.ofNullable(this.securePort);
    }

    /**
     * Pod Security Context to be set on the webhook component Pod. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * 
     */
    @Import(name="securityContext")
    private @Nullable Output<PodSecurityContextArgs> securityContext;

    /**
     * @return Pod Security Context to be set on the webhook component Pod. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
     * 
     */
    public Optional<Output<PodSecurityContextArgs>> securityContext() {
        return Optional.ofNullable(this.securityContext);
    }

    @Import(name="serviceAccount")
    private @Nullable Output<CertManagerServiceAccountArgs> serviceAccount;

    public Optional<Output<CertManagerServiceAccountArgs>> serviceAccount() {
        return Optional.ofNullable(this.serviceAccount);
    }

    /**
     * Optional additional annotations to add to the webhook service
     * 
     */
    @Import(name="serviceAnnotations")
    private @Nullable Output<Map<String,String>> serviceAnnotations;

    /**
     * @return Optional additional annotations to add to the webhook service
     * 
     */
    public Optional<Output<Map<String,String>>> serviceAnnotations() {
        return Optional.ofNullable(this.serviceAnnotations);
    }

    /**
     * Optional additional labels to add to the Webhook Service
     * 
     */
    @Import(name="serviceLabels")
    private @Nullable Output<Map<String,String>> serviceLabels;

    /**
     * @return Optional additional labels to add to the Webhook Service
     * 
     */
    public Optional<Output<Map<String,String>>> serviceLabels() {
        return Optional.ofNullable(this.serviceLabels);
    }

    /**
     * Specifies how the service should be handled. Useful if you want to expose the webhook to outside of the cluster. In some cases, the control plane cannot reach internal services.
     * 
     */
    @Import(name="serviceType")
    private @Nullable Output<String> serviceType;

    /**
     * @return Specifies how the service should be handled. Useful if you want to expose the webhook to outside of the cluster. In some cases, the control plane cannot reach internal services.
     * 
     */
    public Optional<Output<String>> serviceType() {
        return Optional.ofNullable(this.serviceType);
    }

    @Import(name="strategy")
    private @Nullable Output<DeploymentStrategyArgs> strategy;

    public Optional<Output<DeploymentStrategyArgs>> strategy() {
        return Optional.ofNullable(this.strategy);
    }

    @Import(name="timeoutSeconds")
    private @Nullable Output<Integer> timeoutSeconds;

    public Optional<Output<Integer>> timeoutSeconds() {
        return Optional.ofNullable(this.timeoutSeconds);
    }

    @Import(name="tolerations")
    private @Nullable Output<List<TolerationArgs>> tolerations;

    public Optional<Output<List<TolerationArgs>>> tolerations() {
        return Optional.ofNullable(this.tolerations);
    }

    /**
     * Overrides the mutating webhook and validating webhook so they reach the webhook service using the `url` field instead of a service.
     * 
     */
    @Import(name="url")
    private @Nullable Output<CertManagerWebhookURLArgs> url;

    /**
     * @return Overrides the mutating webhook and validating webhook so they reach the webhook service using the `url` field instead of a service.
     * 
     */
    public Optional<Output<CertManagerWebhookURLArgs>> url() {
        return Optional.ofNullable(this.url);
    }

    /**
     * Optional additional annotations to add to the webhook ValidatingWebhookConfiguration
     * 
     */
    @Import(name="validatingWebhookConfigurationAnnotations")
    private @Nullable Output<Map<String,String>> validatingWebhookConfigurationAnnotations;

    /**
     * @return Optional additional annotations to add to the webhook ValidatingWebhookConfiguration
     * 
     */
    public Optional<Output<Map<String,String>>> validatingWebhookConfigurationAnnotations() {
        return Optional.ofNullable(this.validatingWebhookConfigurationAnnotations);
    }

    private CertManagerWebhookArgs() {}

    private CertManagerWebhookArgs(CertManagerWebhookArgs $) {
        this.affinity = $.affinity;
        this.containerSecurityContext = $.containerSecurityContext;
        this.deploymentAnnotations = $.deploymentAnnotations;
        this.extraArgs = $.extraArgs;
        this.hostNetwork = $.hostNetwork;
        this.image = $.image;
        this.livenessProbe = $.livenessProbe;
        this.loadBalancerIP = $.loadBalancerIP;
        this.mutatingWebhookConfigurationAnnotations = $.mutatingWebhookConfigurationAnnotations;
        this.nodeSelector = $.nodeSelector;
        this.podAnnotations = $.podAnnotations;
        this.podLabels = $.podLabels;
        this.readinessProbe = $.readinessProbe;
        this.replicaCount = $.replicaCount;
        this.resources = $.resources;
        this.securePort = $.securePort;
        this.securityContext = $.securityContext;
        this.serviceAccount = $.serviceAccount;
        this.serviceAnnotations = $.serviceAnnotations;
        this.serviceLabels = $.serviceLabels;
        this.serviceType = $.serviceType;
        this.strategy = $.strategy;
        this.timeoutSeconds = $.timeoutSeconds;
        this.tolerations = $.tolerations;
        this.url = $.url;
        this.validatingWebhookConfigurationAnnotations = $.validatingWebhookConfigurationAnnotations;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(CertManagerWebhookArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private CertManagerWebhookArgs $;

        public Builder() {
            $ = new CertManagerWebhookArgs();
        }

        public Builder(CertManagerWebhookArgs defaults) {
            $ = new CertManagerWebhookArgs(Objects.requireNonNull(defaults));
        }

        public Builder affinity(@Nullable Output<AffinityArgs> affinity) {
            $.affinity = affinity;
            return this;
        }

        public Builder affinity(AffinityArgs affinity) {
            return affinity(Output.of(affinity));
        }

        /**
         * @param containerSecurityContext Container Security Context to be set on the webhook component container. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
         * 
         * @return builder
         * 
         */
        public Builder containerSecurityContext(@Nullable Output<SecurityContextArgs> containerSecurityContext) {
            $.containerSecurityContext = containerSecurityContext;
            return this;
        }

        /**
         * @param containerSecurityContext Container Security Context to be set on the webhook component container. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
         * 
         * @return builder
         * 
         */
        public Builder containerSecurityContext(SecurityContextArgs containerSecurityContext) {
            return containerSecurityContext(Output.of(containerSecurityContext));
        }

        /**
         * @param deploymentAnnotations Optional additional annotations to add to the webhook Deployment
         * 
         * @return builder
         * 
         */
        public Builder deploymentAnnotations(@Nullable Output<Map<String,String>> deploymentAnnotations) {
            $.deploymentAnnotations = deploymentAnnotations;
            return this;
        }

        /**
         * @param deploymentAnnotations Optional additional annotations to add to the webhook Deployment
         * 
         * @return builder
         * 
         */
        public Builder deploymentAnnotations(Map<String,String> deploymentAnnotations) {
            return deploymentAnnotations(Output.of(deploymentAnnotations));
        }

        /**
         * @param extraArgs Optional additional arguments for webhook
         * 
         * @return builder
         * 
         */
        public Builder extraArgs(@Nullable Output<List<String>> extraArgs) {
            $.extraArgs = extraArgs;
            return this;
        }

        /**
         * @param extraArgs Optional additional arguments for webhook
         * 
         * @return builder
         * 
         */
        public Builder extraArgs(List<String> extraArgs) {
            return extraArgs(Output.of(extraArgs));
        }

        /**
         * @param extraArgs Optional additional arguments for webhook
         * 
         * @return builder
         * 
         */
        public Builder extraArgs(String... extraArgs) {
            return extraArgs(List.of(extraArgs));
        }

        /**
         * @param hostNetwork Specifies if the webhook should be started in hostNetwork mode. Required for use in some managed kubernetes clusters (such as AWS EKS) with custom CNI (such as calico), because control-plane managed by AWS cannot communicate with pods&#39; IP CIDR and admission webhooks are not working Since the default port for the webhook conflicts with kubelet on the host network, `webhook.securePort` should be changed to an available port if running in hostNetwork mode.
         * 
         * @return builder
         * 
         */
        public Builder hostNetwork(@Nullable Output<Boolean> hostNetwork) {
            $.hostNetwork = hostNetwork;
            return this;
        }

        /**
         * @param hostNetwork Specifies if the webhook should be started in hostNetwork mode. Required for use in some managed kubernetes clusters (such as AWS EKS) with custom CNI (such as calico), because control-plane managed by AWS cannot communicate with pods&#39; IP CIDR and admission webhooks are not working Since the default port for the webhook conflicts with kubelet on the host network, `webhook.securePort` should be changed to an available port if running in hostNetwork mode.
         * 
         * @return builder
         * 
         */
        public Builder hostNetwork(Boolean hostNetwork) {
            return hostNetwork(Output.of(hostNetwork));
        }

        public Builder image(@Nullable Output<CertManagerImageArgs> image) {
            $.image = image;
            return this;
        }

        public Builder image(CertManagerImageArgs image) {
            return image(Output.of(image));
        }

        /**
         * @param livenessProbe Liveness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
         * 
         * @return builder
         * 
         */
        public Builder livenessProbe(@Nullable Output<ProbeArgs> livenessProbe) {
            $.livenessProbe = livenessProbe;
            return this;
        }

        /**
         * @param livenessProbe Liveness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
         * 
         * @return builder
         * 
         */
        public Builder livenessProbe(ProbeArgs livenessProbe) {
            return livenessProbe(Output.of(livenessProbe));
        }

        public Builder loadBalancerIP(@Nullable Output<String> loadBalancerIP) {
            $.loadBalancerIP = loadBalancerIP;
            return this;
        }

        public Builder loadBalancerIP(String loadBalancerIP) {
            return loadBalancerIP(Output.of(loadBalancerIP));
        }

        /**
         * @param mutatingWebhookConfigurationAnnotations Optional additional annotations to add to the webhook MutatingWebhookConfiguration
         * 
         * @return builder
         * 
         */
        public Builder mutatingWebhookConfigurationAnnotations(@Nullable Output<Map<String,String>> mutatingWebhookConfigurationAnnotations) {
            $.mutatingWebhookConfigurationAnnotations = mutatingWebhookConfigurationAnnotations;
            return this;
        }

        /**
         * @param mutatingWebhookConfigurationAnnotations Optional additional annotations to add to the webhook MutatingWebhookConfiguration
         * 
         * @return builder
         * 
         */
        public Builder mutatingWebhookConfigurationAnnotations(Map<String,String> mutatingWebhookConfigurationAnnotations) {
            return mutatingWebhookConfigurationAnnotations(Output.of(mutatingWebhookConfigurationAnnotations));
        }

        public Builder nodeSelector(@Nullable Output<Map<String,String>> nodeSelector) {
            $.nodeSelector = nodeSelector;
            return this;
        }

        public Builder nodeSelector(Map<String,String> nodeSelector) {
            return nodeSelector(Output.of(nodeSelector));
        }

        /**
         * @param podAnnotations Optional additional annotations to add to the webhook Pods
         * 
         * @return builder
         * 
         */
        public Builder podAnnotations(@Nullable Output<Map<String,String>> podAnnotations) {
            $.podAnnotations = podAnnotations;
            return this;
        }

        /**
         * @param podAnnotations Optional additional annotations to add to the webhook Pods
         * 
         * @return builder
         * 
         */
        public Builder podAnnotations(Map<String,String> podAnnotations) {
            return podAnnotations(Output.of(podAnnotations));
        }

        /**
         * @param podLabels Optional additional labels to add to the Webhook Pods
         * 
         * @return builder
         * 
         */
        public Builder podLabels(@Nullable Output<Map<String,String>> podLabels) {
            $.podLabels = podLabels;
            return this;
        }

        /**
         * @param podLabels Optional additional labels to add to the Webhook Pods
         * 
         * @return builder
         * 
         */
        public Builder podLabels(Map<String,String> podLabels) {
            return podLabels(Output.of(podLabels));
        }

        /**
         * @param readinessProbe Readiness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
         * 
         * @return builder
         * 
         */
        public Builder readinessProbe(@Nullable Output<ProbeArgs> readinessProbe) {
            $.readinessProbe = readinessProbe;
            return this;
        }

        /**
         * @param readinessProbe Readiness probe values. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
         * 
         * @return builder
         * 
         */
        public Builder readinessProbe(ProbeArgs readinessProbe) {
            return readinessProbe(Output.of(readinessProbe));
        }

        public Builder replicaCount(@Nullable Output<Integer> replicaCount) {
            $.replicaCount = replicaCount;
            return this;
        }

        public Builder replicaCount(Integer replicaCount) {
            return replicaCount(Output.of(replicaCount));
        }

        public Builder resources(@Nullable Output<ResourceRequirementsArgs> resources) {
            $.resources = resources;
            return this;
        }

        public Builder resources(ResourceRequirementsArgs resources) {
            return resources(Output.of(resources));
        }

        /**
         * @param securePort The port that the webhook should listen on for requests. In GKE private clusters, by default kubernetes apiservers are allowed to talk to the cluster nodes only on 443 and 10250. so configuring securePort: 10250, will work out of the box without needing to add firewall rules or requiring NET_BIND_SERVICE capabilities to bind port numbers &lt;1000
         * 
         * @return builder
         * 
         */
        public Builder securePort(@Nullable Output<Integer> securePort) {
            $.securePort = securePort;
            return this;
        }

        /**
         * @param securePort The port that the webhook should listen on for requests. In GKE private clusters, by default kubernetes apiservers are allowed to talk to the cluster nodes only on 443 and 10250. so configuring securePort: 10250, will work out of the box without needing to add firewall rules or requiring NET_BIND_SERVICE capabilities to bind port numbers &lt;1000
         * 
         * @return builder
         * 
         */
        public Builder securePort(Integer securePort) {
            return securePort(Output.of(securePort));
        }

        /**
         * @param securityContext Pod Security Context to be set on the webhook component Pod. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
         * 
         * @return builder
         * 
         */
        public Builder securityContext(@Nullable Output<PodSecurityContextArgs> securityContext) {
            $.securityContext = securityContext;
            return this;
        }

        /**
         * @param securityContext Pod Security Context to be set on the webhook component Pod. ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
         * 
         * @return builder
         * 
         */
        public Builder securityContext(PodSecurityContextArgs securityContext) {
            return securityContext(Output.of(securityContext));
        }

        public Builder serviceAccount(@Nullable Output<CertManagerServiceAccountArgs> serviceAccount) {
            $.serviceAccount = serviceAccount;
            return this;
        }

        public Builder serviceAccount(CertManagerServiceAccountArgs serviceAccount) {
            return serviceAccount(Output.of(serviceAccount));
        }

        /**
         * @param serviceAnnotations Optional additional annotations to add to the webhook service
         * 
         * @return builder
         * 
         */
        public Builder serviceAnnotations(@Nullable Output<Map<String,String>> serviceAnnotations) {
            $.serviceAnnotations = serviceAnnotations;
            return this;
        }

        /**
         * @param serviceAnnotations Optional additional annotations to add to the webhook service
         * 
         * @return builder
         * 
         */
        public Builder serviceAnnotations(Map<String,String> serviceAnnotations) {
            return serviceAnnotations(Output.of(serviceAnnotations));
        }

        /**
         * @param serviceLabels Optional additional labels to add to the Webhook Service
         * 
         * @return builder
         * 
         */
        public Builder serviceLabels(@Nullable Output<Map<String,String>> serviceLabels) {
            $.serviceLabels = serviceLabels;
            return this;
        }

        /**
         * @param serviceLabels Optional additional labels to add to the Webhook Service
         * 
         * @return builder
         * 
         */
        public Builder serviceLabels(Map<String,String> serviceLabels) {
            return serviceLabels(Output.of(serviceLabels));
        }

        /**
         * @param serviceType Specifies how the service should be handled. Useful if you want to expose the webhook to outside of the cluster. In some cases, the control plane cannot reach internal services.
         * 
         * @return builder
         * 
         */
        public Builder serviceType(@Nullable Output<String> serviceType) {
            $.serviceType = serviceType;
            return this;
        }

        /**
         * @param serviceType Specifies how the service should be handled. Useful if you want to expose the webhook to outside of the cluster. In some cases, the control plane cannot reach internal services.
         * 
         * @return builder
         * 
         */
        public Builder serviceType(String serviceType) {
            return serviceType(Output.of(serviceType));
        }

        public Builder strategy(@Nullable Output<DeploymentStrategyArgs> strategy) {
            $.strategy = strategy;
            return this;
        }

        public Builder strategy(DeploymentStrategyArgs strategy) {
            return strategy(Output.of(strategy));
        }

        public Builder timeoutSeconds(@Nullable Output<Integer> timeoutSeconds) {
            $.timeoutSeconds = timeoutSeconds;
            return this;
        }

        public Builder timeoutSeconds(Integer timeoutSeconds) {
            return timeoutSeconds(Output.of(timeoutSeconds));
        }

        public Builder tolerations(@Nullable Output<List<TolerationArgs>> tolerations) {
            $.tolerations = tolerations;
            return this;
        }

        public Builder tolerations(List<TolerationArgs> tolerations) {
            return tolerations(Output.of(tolerations));
        }

        public Builder tolerations(TolerationArgs... tolerations) {
            return tolerations(List.of(tolerations));
        }

        /**
         * @param url Overrides the mutating webhook and validating webhook so they reach the webhook service using the `url` field instead of a service.
         * 
         * @return builder
         * 
         */
        public Builder url(@Nullable Output<CertManagerWebhookURLArgs> url) {
            $.url = url;
            return this;
        }

        /**
         * @param url Overrides the mutating webhook and validating webhook so they reach the webhook service using the `url` field instead of a service.
         * 
         * @return builder
         * 
         */
        public Builder url(CertManagerWebhookURLArgs url) {
            return url(Output.of(url));
        }

        /**
         * @param validatingWebhookConfigurationAnnotations Optional additional annotations to add to the webhook ValidatingWebhookConfiguration
         * 
         * @return builder
         * 
         */
        public Builder validatingWebhookConfigurationAnnotations(@Nullable Output<Map<String,String>> validatingWebhookConfigurationAnnotations) {
            $.validatingWebhookConfigurationAnnotations = validatingWebhookConfigurationAnnotations;
            return this;
        }

        /**
         * @param validatingWebhookConfigurationAnnotations Optional additional annotations to add to the webhook ValidatingWebhookConfiguration
         * 
         * @return builder
         * 
         */
        public Builder validatingWebhookConfigurationAnnotations(Map<String,String> validatingWebhookConfigurationAnnotations) {
            return validatingWebhookConfigurationAnnotations(Output.of(validatingWebhookConfigurationAnnotations));
        }

        public CertManagerWebhookArgs build() {
            return $;
        }
    }

}
